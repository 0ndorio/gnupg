                                                              -*- outline -*-

* src/base64
** Make parsing more robust
Currently we don't cope with overlong lines in the best way.

* sm/call-agent.c
** The protocol uses an incomplete S-expression
We should always use valid S-Exp and not just parts.
** Some code should go into import.c
** When we allow concurrent service request in gpgsm, we
might want to have an agent context for each service request
(i.e. Assuan context).

* sm/certreqgen.c
** Improve error reporting
** Do some basic checks on the supplied DNs

* sm/certchain.c
** When a certificate chain was sucessfully verified, make ephemeral certs used  in this chain permanent.


* sm/decrypt.c
** replace leading zero in integer hack by a cleaner solution

* sm/gpgsm.c
** Support --output for all commands
** mark all unimplemented commands and options.
** Print a hint when MD2 is the cause for a problem.
** Implement --default-key
** Using --export-secret-key-p12 with a non-pth agent
   This leads to a lockup because gpgsm is still accessing the agent
   while gpg-protect-tool wants to pop up the pinentry.  Solution is
   to release the connection.  This is not trivial, thus we are going
   to do that while changing gpgsm to allow concurrent operations.
** support the anyPolicy semantic
** Check that we are really following the verification procedures in rfc3280.
** Implement a --card-status command.
   This is useful to check whether a card is supported at all.


* sm/keydb.c
** Check file permissions
** Check that all error code mapping is done.
** Remove the inter-module dependencies between gpgsm and keybox
** Add an source_of_key field

* agent/gpg-agent.c
** A SIGHUP should also restart the scdaemon
   But do this only after all connections terminated.  As of now we
   only send a RESET.

* agent/command.c
** Make sure that secure memory is used where appropriate

* agent/pkdecrypt.c, agent/pksign.c
** Don't use stdio to return results.
** Support DSA

* Move pkcs-1 encoding into libgcrypt.

* Use a MAC to protect sensitive files.
  The problem here is that we need yet another key and it is unlikely
  that users are willing to remember that key too.  It is possible to
  do this with a smartcard, though.

* sm/export.c
** Return an error code or a status info per user ID.

* scd/tlv.c
  The parse_sexp fucntion should not go into this file.  Check whether
  we can change all S-expression handling code to make use of this
  function.

* scd
** Application context vs. reader slot
  We have 2 concurrent method of tracking whether a read is in use:
  Using the session_list in command.c and the lock_table in app.c.  IT
  would be better to do this just at one place. First we need to see
  how we can support cards with multiple applications.
   
* tests
** Makefile.am
  We use printf(1) to setup the library path, this is not portable.
  Furthermore LD_LIBRARY_PATH is not used on all systems.  It doesn't
  matter for now, because we use some GNU/*BSDish features anyway.

** Add a test to check the extkeyusage.

* doc/
** Explain how to setup a root CA key as trusted
** Explain how trustlist.txt might be managed.
** Write a script to generate man pages from texi.
   In progress (yatm)


* Windows port
** gpgsm's LISTKEYS does not yet work
    Fix is to change everything to libestream
** Signals are not support 
    This means we can't reread a configuration
** No card status notifications.



