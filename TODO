
    * add assembler support for more CPUs. (work, but easy)
    * improve iobuf by reading more than one byte at once,
      this shoud espceially done for the buffer in the chain.
    * add a way to difference between errors and eof in the underflow/flush
      function of iobuf.
    * check that all output is filtered when displayed.
    * add trust stuff
    * add checking of armor trailers
    * add real secure memory
    * look for a way to reuse RSA signatures
    * remove all "Fixmes"
    * speed up the RIPE-MD-160
    * add signal handling
    * enable a SIGSEGV handler while using zlib functions

    * PGP writes the signature and then the file, this is not
      a good idea, we can't write such files if we take input from stdin.
      So the solution will: accept such packet, but write
      signature the corret way: first the data and then the signature[s]
      this is much easier to check, also we must read the entire data
      before we can check wether we have the pubkey or not.  The one-pass
      signature packets should be implemented to avoid this.

    * complete cipher/cast.c
    * complete cipher/dsa.c

    * define a standard way to specify keyid/userid and other stuff
      to identify a user.  We could look at the first character and
      say: If it's a digit, a keyid follows (need to add a zero in
      case the keyid starts with A..F); if it is a left angle bracket,
      this is a email address and should be used, all others are substrings
      of the userid.
      [can be handles in get_pubkey_by_name()]

    * armor has now some problems.

    * add g10 stuff to Mutt's pgpinvoke.c

    * Burn the buffers used by fopen().

    * bug: g10/trustdb.c#build_sigrecs caled to often by do_list_path
      and remove the bad kludge. Maybe we should put all sigs into the trustdb
      and mark them as valid/invalid/nopubkey, and how do we check, that
      we have a self-signature -> put this stuff into a kind of directory
      record, as it does not belong to the pubkey record?

